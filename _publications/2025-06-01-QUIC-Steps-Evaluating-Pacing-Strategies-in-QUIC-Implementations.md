---
title: "QUIC Steps: Evaluating Pacing Strategies in QUIC Implementations"
collection: publications
permalink: /publication/2025-06-01-QUIC-Steps-Evaluating-Pacing-Strategies-in-QUIC-Implementations
important: "true"
date: 2025-06-01
venue: 'Proc. ACM Netw.'
citation: 'Marcel Kempf, Simon Tietz, Benedikt Jaeger, Johannes Sp{\&quot;a}th, Georg Carle, <b>Johannes Zirngibl</b>, &quot;QUIC Steps: Evaluating Pacing Strategies in QUIC Implementations.&quot; Proc. ACM Netw., 2025.'
authors: 'Marcel Kempf, Simon Tietz, Benedikt Jaeger, Johannes Sp{\"a}th, Georg Carle, <b>Johannes Zirngibl</b>'
abstract: "Pacing is a key mechanism in modern transport protocols, used to regulate packet transmission timing to minimize traffic burstiness, lower latency, and reduce packet loss. Standardized in 2021, QUIC is a UDP-based protocol designed to improve upon the TCP / TLS stack. While the QUIC protocol recommends pacing, and congestion control algorithms like BBR rely on it, the user-space nature of QUIC introduces unique challenges. These challenges include coarse-grained timers, system call overhead, and OS scheduling delays, all of which complicate precise packet pacing. This paper investigates how pacing is implemented differently across QUIC stacks, including quiche, picoquic, and ngtcp2, and evaluates the impact of system-level features like GSO and Linux qdiscs on pacing. Using a custom measurement framework and a passive optical fiber tap, we establish a baseline with default settings and systematically explore the effects of qdiscs, hardware offloading using the ETF qdisc, and GSO on pacing precision and network performance. We also extend and evaluate a kernel patch to enable pacing of individual packets within GSO buffers, combining batching efficiency with precise pacing. Kernel-assisted and purely user-space pacing approaches are compared. We show that pacing with only user-space timers can work well, as demonstrated by picoquic with BBR. With quiche, we identify FQ as a qdisc well-suited for pacing QUIC traffic, as it is relatively easy to use and offers precise pacing based on packet timestamps. We uncovered that internal mechanisms, such as a libraryâ€™s spurious loss detection logic or algorithms such as HyStart++, can interfere with pacing and cause issues like unstable congestion windows and increased packet loss. Our findings provide new insights into the trade-offs involved in implementing pacing in QUIC and highlight potential optimizations for real-world applications like video streaming and video calls."
---
[<i class="ai ai-google-scholar"></i>](https://scholar.google.com/scholar?q=QUIC+Steps:+Evaluating+Pacing+Strategies+in+QUIC+Implementations){: .btn--research-inverse} [<i class="fas fa-file-pdf"></i>](/files/kempf2025quicpacing.pdf){: .btn--research-inverse} [Homepage](https://github.com/tumi8/quic-pacing-paper){: .btn--research}